---
applyTo: "**"
---

# AI Coding Assistant Guidelines for LF Widgets

These instructions help an AI agent work productively in this monorepo.

## 1. Architecture Big Picture

- Monorepo (Yarn v4 workspaces + Lerna) with packages:
  - `@lf-widgets/foundations`: Pure type declarations, constants, shared declarations (DO NOT add runtime logic here).
  - `@lf-widgets/framework`: The singleton core (see `src/lf-framework/lf-framework.ts`) providing modules: theme, data, debug, drag, effects, llm, portal, color, utilities. Components obtain it via helper (e.g. `awaitFramework`). All cross‑cutting services live here.
  - `@lf-widgets/core`: Stencil web components. Each component folder: `lf-<name>/` with `<name>.tsx`, optional adapters, SCSS, scripts. Components emit a single consolidated event (`lf-<name>-event`) carrying `eventType` and contextual data.
  - `@lf-widgets/showcase`: Demo + documentation site; builds docs from `core/doc.json` via `packages/core/src/scripts/doc.js` into `assets/doc.ts`.
  - React wrappers: `react-core`, `react-showcase` (generated by Stencil react-output-target).
  - `assets`: Fonts, svg, showcase static assets.
- Data layer: Dataset shape (`LfDataDataset`) with `nodes` + optional `columns`, nodes with `cells` containers referencing typed shapes (badge, button, etc.). Generic manipulation via `framework.data` (see `lf-data` directory). Components should not manually walk complex structures if helper exists.
- Theming: `framework.theme` provides `bemClass`, registration (`register/unregister` in lifecycle), CSS variables, UI size/state tokens. Avoid ad-hoc class name generation; rely on block maps imported from foundations (e.g. `LF_TREE_BLOCKS`).
- Effects: Ripple, etc., accessed from `framework.effects` rather than reimplementing animations.

## 2. Build & Dev Workflows

- Install: `yarn install` (Yarn v4, do not use npm).
- Full build: `yarn build` (order: foundations → framework → core → sync docs/mixins → showcase → react packages → markdown propagation).
- Dev (showcase hot reload): `yarn dev:setup` (initial build + `lerna run dev` for showcase). Subsequent runs can use `yarn dev` if packages already built.
- Cleaning: `yarn clean` (runs each package clean + script cleanup).
- Docs regeneration: `yarn doc` then `yarn sync:showcase` (usually covered by full build).
- SCSS lint safeguard: prebuild runs `lint:scss-modules` script to forbid direct SCSS imports into modules.

## 3. Component Conventions

- Always `@Component({ tag: 'lf-xyz', shadow: true })` and expose props with `@Prop({ mutable: true, reflect?: true })` when they must update dynamically or reflect to attributes.
- Single event pattern: Each component defines `@Event({ eventName: 'lf-xyz-event' })` and helper `onLfEvent` centralizing switch logic. New interactions should emit through this channel; avoid multiple custom event names.
- Public API methods exposed with `@Method()` return promises.
- State with `@State()` for reactive internals; prefer Sets cloned (`new Set(set)`) to trigger updates.
- Theme registration: call `this.#framework.theme.register(this)` in `connectedCallback` (if framework already resolved) and `unregister` in `disconnectedCallback`.
- Filtering / debouncing pattern: Use a private timeout (`#filterTimeout`) as in `lf-tree` & `lf-list` (300ms) when reacting to textfield input.
- Data rendering: Use `framework.data.cell.stringify` for textual fallback; use `framework.data.cell.shapes.get` to transform shape props before spreading into shape components.
- BEM classes: Never hardcode strings beyond suffix utility classes. Use block maps: `LF_<COMP>_BLOCKS` and `theme.bemClass(block._, block.part, { modifier: cond })`.

## 4. Data & Cells

- `LfDataDataset`: `{ nodes: LfDataNode[], columns?: LfDataColumn[] }`. For grid-like components (tree grid, compare, masonry), leverage `data.cell.shapes.getAll` to precompute shapes or `cell.shapes.get(cell)` inline.
- Cells: Each node `cells` entry keyed by a column id or semantic key; `cell.shape` drives which web component to render. If no shape, treat as text.
- Use helpers in `lf-data/helpers.cell.tsx` & `helpers.node.ts` instead of reimplementing search, filtering, parent lookup, etc.

## 5. Adding / Modifying Components

- Add directory under `packages/core/src/components/lf-<name>/` with SCSS, TSX, optional adapters.
- Export types in foundations only if part of public contract (update relevant `*.declarations.ts`). Do NOT put runtime code in foundations.
- Update `doc.json` via Stencil build; `yarn doc` regenerates typed docs consumed by showcase.
- Ensure new props are added to `<COMP>_PROPS` list constant so `getProps()` works.
- Follow existing pattern for shape rendering if component consumes datasets.

## 6. Styling & Theming

- SCSS uses custom mixins (`packages/core/src/components/lf-tree/variables|mixins`). Use `lf-comp-*` and `lf-el-*` mixins for consistent look (glassmorphism, transitions, text styles).
- Expose overridable CSS props with JSDoc `@prop` comments inside SCSS (see `lf-tree.scss` for pattern). Keep naming `--lf-<component>-<token>`.

## 7. Events & Effects

- Ripple: Only trigger if `lfRipple` is true; effect uses stored element refs (see `#r` map). Maintain this pattern for any pointer-based visual effects.
- Selection vs expansion: Tree / list components differentiate click contexts via an `args` object in `onLfEvent`; replicate approach for hierarchical interactions.

## 8. Testing & QA

- Cypress configured in `packages/showcase/cypress`. Component examples in showcase become test targets; when adding examples, give deterministic props if writing tests (avoid random\* unless specifically for visual variety).

## 9. Documentation & Showcase

- Showcase examples defined in `packages/showcase/src/components/lf-showcase/assets/data/*.ts` via fixture factories (`getTreeFixtures`, etc.). Add new example variants there when expanding functionality.
- Doc generation script transforms `core/doc.json` (Stencil output) to `showcase/assets/doc.ts`; avoid manual edits to generated `doc.ts`.

## 10. Common Pitfalls

- Forgetting to update foundations declarations for new public props => TypeScript errors when used in showcase fixtures.
- Not cloning mutable Sets after mutation prevents Stencil re-render.
- Adding runtime imports into foundations breaks layering intent.
- Bypassing `awaitFramework` before framework initialization leads to undefined service usage in lifecycle hooks.

## 11. Quick Reference Commands

- Build all: `yarn build`
- Dev showcase (after initial setup): `yarn dev`
- Initial dev (ensures packages built): `yarn dev:setup`
- Regenerate docs + copy mixins: `yarn sync:showcase`
- Clean: `yarn clean`

## 12. Absolute don'ts

- Use `!important` in styles unless absolutely necessary.
- Use `any` type in TypeScript.
- Irregard for alphabetical order when plugging in new snippets.
- Insertion of anti-patterns.
- Opting for `WET` (Write Everything Twice) against `DRY` (Don't Repeat Yourself).

---

Provide concise PR descriptions; reference components and props changed. Ask if unclear how to expose new data shapes or events.
