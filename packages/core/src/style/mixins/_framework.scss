@use "sass:map";
@use "./elements" as *;
@use "./helpers" as *;
@use "../_variables" as *;

/*******************************************
 * @mixin lf-fw-effect-layers
 * Base styles for all effect layers created by the layer manager.
 * Uses [data-lf-effect-layer] attribute selector to target all layers
 * with a single rule, avoiding inline style duplication.
 *
 * Dynamic properties (z-index) are still set inline by the layer manager.
 *******************************************/
@mixin lf-fw-effect-layers {
  // Universal layer base - targets ALL effect layers
  [data-lf-effect-layer] {
    border-radius: inherit;
    inset: 0;
    overflow: hidden;
    pointer-events: none;
    position: absolute;
  }

  [data-lf-effect-layer][data-lf-pointer-events] {
    pointer-events: auto;
  }

  [data-lf-effect-layer][data-lf-no-radius] {
    border-radius: 0;
  }
}

/*******************************************
 * @mixin lf-fw-backdrop
 * Creates a full-screen backdrop element with a fade-in-out transition.
 *******************************************/
@mixin lf-fw-backdrop {
  [data-lf="backdrop"] {
    @include lf-el-transition("fade-in-out");

    background: rgba(0, 0, 0, 0.375);
    height: 100vh;
    left: 0;
    opacity: 0;
    position: fixed;
    top: 0;
    width: 100vw;
    z-index: var(--lf-ui-zindex-backdrop, 899);

    @include lf-keyframe(lf-fade-in, map.get($lf-keyframes, fade-in));
  }
}
/*******************************************
 * @mixin lf-fw-fade-in
 * Applies a fade-in animation to any element with [data-lf="fade-in"].
 *
 * @param {String} $display - Which display property to use (e.g. "block", "flex").
 *                            Defaults to "block".
 *******************************************/
@mixin lf-fw-fade-in($display: block) {
  [data-lf="fade-in"] {
    animation: lf-fade-in-#{$display} 0.25s ease-out forwards;
    display: $display;
    @include lf-keyframe(
      lf-fade-in-#{$display},
      map.get($lf-keyframes, fade-in)
    );
  }
}
/*******************************************
 * @mixin lf-fw-lightbox
 * Creates a fixed-position lightbox container for modal content.
 *******************************************/
@mixin lf-fw-lightbox {
  [data-lf="lightbox"] {
    @include lf-el-transition("fade-in-out");
    height: 90dvh;
    left: 5dvw;
    position: fixed;
    top: 5dvh;
    width: 90dvw;
    z-index: var(--lf-ui-zindex-lightbox, 900);
  }

  [data-lf="lightbox-content"] {
    @include lf-el-stretch;
    border: 1px solid rgba(var(--lf-color-border), 0.375);
    border-radius: var(--lf-ui-border-radius);
    box-sizing: border-box;
    outline: none;
    z-index: calc(var(--lf-ui-zindex-lightbox, 900) + 1);

    @include lf-keyframe(lf-pop, map.get($lf-keyframes, pop));
  }
}
/*******************************************
 * @mixin lf-fw-neon-glow-host
 * Defines host styling for elements with the neon-glow effect.
 * Uses [data-lf-neon-glow-host] which is automatically added by the layer manager.
 * 
 * NOTE: Only the Light DOM selector is defined here.
 * The Shadow DOM :host() variant is auto-generated by transformToHostSelector()
 * in helpers.shared-styles.ts when building adopted stylesheets.
 * 
 * Neon-glow needs:
 * - transform-style:preserve-3d for 3D layering context
 * - overflow:visible to allow glow layers to render beyond host bounds
 *******************************************/
@mixin lf-fw-neon-glow-host {
  // Light DOM selector - transformed to :host() for shadow DOM by shared-styles
  [data-lf-neon-glow-host] {
    overflow: visible;
    transform-style: preserve-3d;
  }
}
/*******************************************
 * @mixin lf-fw-neon-glow
 * Adds animated neon glow effect with pulsating border and optional reflection.
 * Supports "outline" (border only) and "filled" (with background) modes.
 * Uses hierarchical attribute pattern: [data-lf-neon-glow] for composability.
 * 
 * Performance: The glow animation uses box-shadow on a layer element.
 * box-shadow is GPU-accelerated and much faster than filter: drop-shadow().
 * Using a layer element instead of ::after allows composability with tilt effect.
 *
 * @param {Color} $default-color - Fallback neon color if CSS var not set.
 *******************************************/
@mixin lf-fw-neon-glow($default-color: rgba(var(--lf-color-secondary), 1)) {
  [data-lf-neon-glow] {
    --lf-ui-neon-color: #{$default-color};
    --lf-ui-neon-intensity: 0.7;
    --lf-ui-neon-pulse-duration: 8s;

    position: relative;
    border: 2px solid var(--lf-ui-neon-color);
    border-radius: var(--lf-ui-border-radius, 0.5em);
    transform-style: preserve-3d;

    // Flicker animation on the main element (opacity only - very cheap)
    animation: lf-neon-flicker calc(var(--lf-ui-neon-pulse-duration) * 1.5)
      linear infinite;

    @include lf-keyframe(lf-neon-flicker, map.get($lf-keyframes, neon-flicker));

    // Text glow for direct children
    & > * {
      text-shadow:
        0 0 5px var(--lf-ui-neon-color),
        0 0 10px var(--lf-ui-neon-color),
        0 0 20px var(--lf-ui-neon-color);
    }
  }

  [data-lf-effect-layer="neon-glow-border"] {
    inset: -1px;
    border-radius: inherit;
    padding: 2px;
    background: linear-gradient(
      135deg,
      var(--lf-ui-neon-color),
      transparent 50%,
      var(--lf-ui-neon-color)
    );
    mask:
      linear-gradient(#fff 0 0) content-box,
      linear-gradient(#fff 0 0);
    mask-composite: exclude;
    -webkit-mask-composite: xor;
    opacity: var(--lf-ui-neon-intensity);
    transform: translateZ(0);
  }

  [data-lf-effect-layer="neon-glow"] {
    will-change: box-shadow;
    box-shadow:
      0 0 3px var(--lf-ui-neon-color),
      0 0 8px var(--lf-ui-neon-color),
      0 0 15px var(--lf-ui-neon-color),
      inset 0 0 3px var(--lf-ui-neon-color);
    animation: lf-neon-glow-pulse var(--lf-ui-neon-pulse-duration) ease-in-out
      infinite;

    @include lf-keyframe(
      lf-neon-glow-pulse,
      map.get($lf-keyframes, neon-glow-pulse)
    );
  }

  // Outline mode (value encodes mode)
  [data-lf-neon-glow="outline"] {
    background: transparent;
  }

  // Filled mode
  [data-lf-neon-glow="filled"] {
    background: color-mix(
      in srgb,
      var(--lf-ui-neon-color) calc(var(--lf-ui-neon-intensity) * 15%),
      transparent
    );
    backdrop-filter: blur(4px);
  }

  // Reflection layer element (injected by layerManager)
  // Positioned OUTSIDE and BELOW the host element to create floor reflection
  // Reference: Simulates light pooling on a reflective surface beneath the element
  // NOTE: Kept within host width to avoid causing page overflow; box-shadow provides visual spread
  [data-lf-effect-layer="neon-glow-reflection"] {
    --lf-ui-neon-reflection-blur: 12px;
    --lf-ui-neon-reflection-offset: 5%;
    --lf-ui-neon-reflection-opacity: 0.7;

    // Position below host, staying within horizontal bounds to prevent overflow
    inset: unset;
    top: 100%;
    left: 0;
    right: 0;
    height: 60%;
    margin-top: var(--lf-ui-neon-reflection-offset);

    // Slight perspective compression for floor effect
    transform: perspective(200px) rotateX(25deg) scaleY(0.6);
    transform-origin: top center;

    // Visual styling - enhanced blur for soft pool of light
    filter: blur(var(--lf-ui-neon-reflection-blur));
    opacity: var(--lf-ui-neon-reflection-opacity);

    // Radial gradient fade - bright center, fading edges (floor light pool)
    mask-image: radial-gradient(
      ellipse 70% 90% at 50% 0%,
      black 0%,
      rgba(0, 0, 0, 0.7) 30%,
      transparent 65%
    );
    -webkit-mask-image: radial-gradient(
      ellipse 70% 90% at 50% 0%,
      black 0%,
      rgba(0, 0, 0, 0.7) 30%,
      transparent 65%
    );

    // Intense multi-layered box-shadow for vivid neon pool effect
    box-shadow:
      0 0 10px 5px var(--lf-ui-neon-color),
      0 0 25px 15px var(--lf-ui-neon-color),
      0 0 50px 25px var(--lf-ui-neon-color),
      0 0 80px 40px var(--lf-ui-neon-color);

    // Solid background glow to intensify the reflection
    background: radial-gradient(
      ellipse 90% 60% at 50% 10%,
      var(--lf-ui-neon-color) 0%,
      color-mix(in srgb, var(--lf-ui-neon-color) 70%, transparent) 30%,
      transparent 60%
    );

    animation: lf-neon-glow-pulse var(--lf-ui-neon-pulse-duration, 8s)
      ease-in-out infinite;

    @include lf-keyframe(
      lf-neon-glow-pulse,
      map.get($lf-keyframes, neon-glow-pulse)
    );
  }
}

/*******************************************
 * @mixin lf-fw-portal
 * Simple conditional portal display mixin.
 *
 * @param {Boolean} $active - If true, displays the portal; if false, hides it (display: none).
 *******************************************/
@mixin lf-fw-portal($active: false) {
  [data-lf="portal"] {
    display: if($active, block, none);

    @if $active {
      height: auto;
      max-height: 45dvh;
      max-width: 45dvw;
      overflow: auto;
      position: fixed;
      width: auto;
      z-index: var(--lf-ui-zindex-portal);

      @media (max-width: 600px) {
        max-height: 80dvh;
        max-width: 90dvw;
      }
    }
  }
}
/*******************************************
 * @mixin lf-fw-ripple-host
 * Defines host styling for elements with the ripple effect.
 * Uses [data-lf-ripple-host] which is automatically added by the layer manager.
 * 
 * NOTE: Only the Light DOM selector is defined here.
 * The Shadow DOM :host() variant is auto-generated by transformToHostSelector()
 * in helpers.shared-styles.ts when building adopted stylesheets.
 *
 * Ripple needs:
 * - position:relative to contain the absolutely positioned layer
 * - overflow:hidden to prevent ripple from extending beyond host bounds
 *******************************************/
@mixin lf-fw-ripple-host {
  // Light DOM selector - transformed to :host() for shadow DOM by shared-styles
  [data-lf-ripple-host] {
    position: relative;
    overflow: hidden;
  }
}
/*******************************************
 * @mixin lf-fw-ripple
 * Defines a ripple element and its animation for material-style click feedback.
 * Uses hierarchical attribute pattern: [data-lf-ripple] for composability.
 *******************************************/
@mixin lf-fw-ripple {
  [data-lf-ripple] {
    animation-duration: var(--lf-ui-ripple-duration, 675ms);
    animation-fill-mode: forwards;
    animation-name: lf-ripple;
    animation-timing-function: var(--lf-ui-ripple-easing, ease-out);
    background: var(--lf-ui-ripple-background, var(--lf-color-primary));
    border-radius: var(--lf-ui-ripple-border-radius, 50%);
    height: var(--lf-ui-ripple-height, 100%);
    left: var(--lf-ui-ripple-x, 50%);
    opacity: var(--lf-ui-ripple-opacity, 0.5);
    pointer-events: none;
    position: absolute;
    top: var(--lf-ui-ripple-y, 50%);
    transform: scale(0);
    width: var(--lf-ui-ripple-width, 100%);

    @include lf-keyframe(lf-ripple, map.get($lf-keyframes, ripple));
  }
}
/*******************************************
 * @mixin lf-fw-state-colors
 * Dynamically sets custom properties for various "states" (hover, active, disabled, etc.)
 * Each state in $lf-states-colors maps to a base color variable and an optional "rgb" variant.
 *
 * @param {String} $comp - Component ID/key (used for namespacing the custom props).
 *******************************************/
@mixin lf-fw-state-colors($comp) {
  @each $state, $colors in $lf-states-colors {
    [data-lf="#{$state}"] {
      @if $state != "primary" {
        @if $state == "disabled" {
          opacity: var(
            --lf-#{$comp}-ui-opacity-disabled,
            var(--lf-ui-opacity-disabled)
          );
          pointer-events: none;
        } @else {
          @each $key, $base-var in $colors {
            --lf-#{$comp}-color-#{$key}: var(
              --lf-#{$comp}-color-#{$state},
              var(#{$base-var})
            );
          }
        }
      }
    }
  }
}
/*******************************************
 * @mixin lf-fw-tilt-host
 * Defines host styling for elements with the tilt effect.
 * Uses [data-lf-tilt-host] which is automatically added by the layer manager.
 * 
 * NOTE: Only Light DOM selectors are defined here.
 * The Shadow DOM :host() variants are auto-generated by transformToHostSelector()
 * in helpers.shared-styles.ts when building adopted stylesheets.
 *
 * Tilt needs:
 * - position:relative to contain the absolutely positioned highlight layer
 * - overflow:hidden to clip the highlight layer
 * - transform with CSS variable for composed rotations
 * - transition for smooth animation
 * - transform-style:preserve-3d for 3D context
 * - will-change:transform for GPU optimization
 *******************************************/
@mixin lf-fw-tilt-host {
  // Light DOM selector - transformed to :host() for shadow DOM by shared-styles
  [data-lf-tilt-host] {
    position: relative;
    overflow: hidden;
    transform: var(--lf-ui-effects-transform, none);
    transition: transform 275ms ease-out;
    transform-style: preserve-3d;
    will-change: transform;

    &:hover {
      box-shadow: 0 15px 30px
        rgba(var(--lf-color-on-bg), var(--lf-ui-alpha-glass, 0.375));
    }
  }

  // Light DOM: hover state for highlight layer
  [data-lf-tilt-host]:hover > [data-lf-effect-layer="tilt-highlight"] {
    background: radial-gradient(
      circle at var(--lf-ui-tilt-light-x, 50%) var(--lf-ui-tilt-light-y, 50%),
      rgba(var(--lf-color-primary), var(--lf-ui-alpha-glass-hint, 0.275)),
      transparent
    );
  }
}
/*******************************************
 * @mixin lf-fw-tilt
 * Adds a 3D tilt/hover effect to the element, with a dynamic radial highlight.
 * Uses layer-based approach for composability with other effects.
 *
 * Transform composition: The layer manager composes all effect transforms
 * into --lf-ui-effects-transform. This allows N effects to coexist without
 * overwriting each other's transforms.
 *
 * @param {Number} $intensity - (Unused directly here) Potentially used for scaling the tilt.
 * @param {Time}   $transition - Transition duration (e.g., 275ms).
 *******************************************/
@mixin lf-fw-tilt($intensity: 10, $transition: 275ms) {
  [data-lf-effect-layer="tilt-highlight"] {
    background: transparent;
    border-radius: inherit;
    inset: 0;
    mix-blend-mode: screen;
    overflow: hidden;
    pointer-events: none;
    position: absolute;
    transition: background $transition ease-out;
  }
}
