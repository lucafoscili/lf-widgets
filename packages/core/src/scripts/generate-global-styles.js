const { readFileSync, unlinkSync, writeFileSync } = require("node:fs");
const { tmpdir } = require("node:os");
const { resolve } = require("node:path");
const { pathToFileURL } = require("node:url");

const sass = require("sass");
const { parse } = require("css");

const AUTO_GENERATED_HEADER = `/* eslint-disable */\n/**\n * This file is auto-generated by scripts/generateGlobalStyles.js.\n * Do not edit manually; update packages/core/src/style/global.scss instead.\n */\n\n`;

const toObject = (map) => {
  const obj = {};

  for (const [key, value] of map.entries()) {
    obj[key] = value;
  }

  return obj;
};

const collectRuleDeclarations = (rule) => {
  const declarations = {};

  for (const declaration of rule.declarations ?? []) {
    if (declaration.type !== "declaration" || !declaration.property) {
      continue;
    }

    declarations[declaration.property] = declaration.value ?? "";
  }

  return declarations;
};

const createGlobalStylesMap = (scssPath) => {
  const rawSource = readFileSync(scssPath, "utf8");
  const source = `@use "mixins" as *;\n${rawSource}`;

  const compileOptions = {
    style: "expanded",
    loadPaths: [resolve(__dirname, "../style")],
  };

  const result =
    typeof sass.compileString === "function"
      ? sass.compileString(source, {
          ...compileOptions,
          url: pathToFileURL(scssPath),
        })
      : (() => {
          const tempFile = resolve(
            tmpdir(),
            `lf-global-${Date.now()}-${Math.random().toString(36).slice(2)}.scss`,
          );

          writeFileSync(tempFile, source, "utf8");

          try {
            return sass.compile(tempFile, compileOptions);
          } finally {
            unlinkSync(tempFile);
          }
        })();

  const { css } = result;
  const ast = parse(css, { silent: false });

  const styles = new Map();

  for (const node of ast.stylesheet?.rules ?? []) {
    if (!node) {
      continue;
    }

    if (node.type === "rule") {
      const declarations = collectRuleDeclarations(node);

      for (const selector of node.selectors ?? []) {
        if (!selector) {
          continue;
        }

        const existing = styles.get(selector);

        if (existing) {
          styles.set(selector, { ...existing, ...declarations });
        } else {
          styles.set(selector, { ...declarations });
        }
      }

      continue;
    }

    if (node.type === "media") {
      const selectorMap = new Map();

      for (const child of node.rules ?? []) {
        if (!child) {
          continue;
        }

        if (child.type === "comment") {
          continue;
        }

        if (child.type !== "rule") {
          throw new Error(`Unsupported media child rule type: ${child.type}`);
        }

        const declarations = collectRuleDeclarations(child);

        for (const selector of child.selectors ?? []) {
          if (!selector) {
            continue;
          }

          const existing = selectorMap.get(selector);

          if (existing) {
            selectorMap.set(selector, { ...existing, ...declarations });
          } else {
            selectorMap.set(selector, { ...declarations });
          }
        }
      }

      const mediaKey = `@media ${node.media}`;
      const existingSelectors = styles.get(mediaKey) ?? {};
      const mergedSelectors = { ...existingSelectors };

      for (const [selector, declarations] of selectorMap.entries()) {
        const current = mergedSelectors[selector];
        mergedSelectors[selector] = current
          ? { ...current, ...declarations }
          : { ...declarations };
      }

      styles.set(mediaKey, mergedSelectors);

      continue;
    }

    if (node.type === "keyframes") {
      const frames = [];

      for (const frame of node.keyframes ?? []) {
        if (frame.type !== "keyframe") {
          continue;
        }

        const declarations = {};

        for (const declaration of frame.declarations ?? []) {
          if (declaration.type !== "declaration" || !declaration.property) {
            continue;
          }

          declarations[declaration.property] = declaration.value ?? "";
        }

        for (const value of frame.values ?? []) {
          if (!value) {
            continue;
          }

          frames.push({ [value]: { ...declarations } });
        }
      }

      styles.set(`@keyframes ${node.name}`, frames);
      continue;
    }

    if (node.type === "comment") {
      continue;
    }

    throw new Error(`Unsupported at-rule type: ${node.type}`);
  }

  return toObject(styles);
};

const formatGlobalStylesModule = (map) => {
  const json = JSON.stringify(map, null, 2);

  return `${AUTO_GENERATED_HEADER}export const GLOBAL_STYLES = ${json} as const;\n`;
};

const writeGlobalStylesModule = (map, outFilePath) => {
  const content = formatGlobalStylesModule(map);

  writeFileSync(outFilePath, content, "utf8");
};

const parseCliArgs = () => {
  const args = process.argv.slice(2);

  const options = {
    input: resolve(__dirname, "../style/global.scss"),
    output: resolve(
      __dirname,
      "../../..",
      "foundations/src/framework/theme.global-styles.generated.ts",
    ),
    json: false,
  };

  for (const arg of args) {
    if (arg === "--json") {
      options.json = true;
      continue;
    }

    if (arg.startsWith("--input=")) {
      const inputPath = arg.slice("--input=".length);
      options.input = resolve(process.cwd(), inputPath);
      continue;
    }

    if (arg.startsWith("--output=")) {
      const outputPath = arg.slice("--output=".length);
      options.output = resolve(process.cwd(), outputPath);
      continue;
    }
  }

  return options;
};

const runFromCli = () => {
  const { input, output, json } = parseCliArgs();

  const map = createGlobalStylesMap(input);

  if (json) {
    process.stdout.write(`${JSON.stringify(map, null, 2)}\n`);
    return;
  }

  writeGlobalStylesModule(map, output);
};

if (require.main === module) {
  runFromCli();
}

module.exports = {
  createGlobalStylesMap,
  formatGlobalStylesModule,
  writeGlobalStylesModule,
};
