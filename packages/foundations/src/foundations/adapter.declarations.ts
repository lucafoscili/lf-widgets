import type { ECElementEvent } from "echarts";
import { LfComponent, VNode } from "./components.declarations";
import { LfEvent } from "./events.declarations";

//#region Adapter
/**
 * Describes the surface exposed by the adapter that wires a Web Component into
 * the hosting integration layer.
 *
 * @template C Controls the component instance exposed through `controller.get.compInstance`.
 * @template H Shape of the handler map exposed through the adapter.
 * @template J Shape of the JSX factory helpers generated by the adapter.
 * @template R Shape of the DOM references tree returned by the adapter.
 * @template CGet Record of controller getters exposed via `controller.get`.
 * @template CSet Record of controller setters exposed via `controller.set`.
 */
export interface LfComponentAdapter<
  C extends LfComponent,
  H = LfComponentAdapterHandlers,
  J = LfComponentAdapterJsx,
  R = LfComponentAdapterRefs,
  CGet = LfComponentAdapterGetters<C>,
  CSet = LfComponentAdapterSetters,
> {
  controller?: {
    /**
     * Collection of read-only hooks surfaced to host frameworks.
     */
    get: CGet;
    /**
     * Optional namespace containing imperative entry points exposed to the host.
     */
    set?: CSet;
  };
  elements?: {
    /**
     * Lazy JSX factories responsible for rendering adapter-managed fragments.
     */
    jsx: J;
    /**
     * Structured registry of DOM references captured during render.
     */
    refs: R;
  };
  /**
   * Event handlers and callbacks wired by the adapter.
   */
  handlers?: H;
}
//#endregion

//#region Handlers
/**
 * Function signature shared by every adapter handler.
 *
 * Handlers receive the originating DOM or framework event along with optional
 * positional arguments and may resolve synchronously or asynchronously.
 */
export type LfComponentAdapterHandler = (
  e?: ECElementEvent | Event | PointerEvent | LfEvent,
  ...args: unknown[]
) => unknown | Promise<unknown>;
/**
 * Nested dictionary of adapter handlers grouped by namespace keys.
 *
 * The recursive shape lets adapters organise handlers without losing type safety.
 */
export type LfComponentAdapterHandlers = {
  [key: string]: LfComponentAdapterHandler | LfComponentAdapterHandlers;
};
//#endregion

//#region Elements
/**
 * Dictionary of JSX factory helpers that generate Stencil `VNode` fragments.
 *
 * Entries may be render helpers or nested namespaces of helpers.
 */
export type LfComponentAdapterJsx = {
  [key: string]: ((...args: unknown[]) => VNode) | LfComponentAdapterJsx;
};
/**
 * Recursive dictionary of DOM references collected from the rendered tree.
 */
export type LfComponentAdapterRefs = {
  [key: string]:
    | Map<string, HTMLElement>
    | HTMLElement
    | LfComponentAdapterRefs;
};
//#endregion

//#region Controller
/**
 * Record of controller getters exposed by an adapter.
 *
 * Every adapter injects the live component instance under `compInstance` and
 * can surface additional read-only values.
 *
 * @template C Component interface whose instance is exposed through the getters.
 */
export type LfComponentAdapterGetters<C extends LfComponent> = {
  [key: string]: unknown;
  /**
   * Live component instance forwarded to external controllers for direct access
   * to public methods or state.
   */
  compInstance: C;
};
/**
 * Record of controller setter functions exposed by an adapter.
 *
 * Setter namespaces allow hierarchical grouping of imperative entry points.
 */
export type LfComponentAdapterSetters = {
  /**
   * Functions exposed to the host. Nested namespaces allow grouping related
   * actions (for example `dialog.open`).
   */
  [key: string]: ((...args: unknown[]) => void) | LfComponentAdapterSetters;
};
//#endregion
